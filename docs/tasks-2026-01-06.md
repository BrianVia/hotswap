# Comprehensive Codebase Analysis: Dynomite

**Date:** 2026-01-06
**Analysis Type:** Full codebase review

---

## Implementation Status

| Issue | Status |
|-------|--------|
| Critical #1: Query Progress Race Condition | ✅ FIXED |
| Critical #2: Numeric Query Parameters | ✅ FIXED |
| Critical #3: Batch Writes Not Batched | ✅ FIXED |
| Critical #4: Pending Changes Error Handling | ✅ FIXED |
| High #5: Input Validation in IPC Handlers | ✅ FIXED |
| High #6-8, Medium #9-12 | ⏳ Pending |

**Build Status:** TypeScript ✅ | Build ✅

---

## Critical Issues (Fix Immediately)

### 1. Race Condition: Query Progress Events Are Unscoped
**Location:** `electron/ipc/handlers.ts:200`, `src/components/TabContent.tsx`

Progress events (`query-progress`, `write-progress`) are broadcast globally without scoping. Running parallel queries in different tabs causes event interleaving - progress updates from Query A corrupt results in Tab B.

```typescript
// electron/ipc/handlers.ts:200 - broadcasts to ALL subscribers
event.sender.send('query-progress', progress);
```

The `queryIdCounter` increments and sends a `queryId`, but the renderer never filters by it.

**Fix:** Have the renderer filter events by matching the `queryId` it initiated.

---

### 2. Numeric Query Parameters Silently Fail
**Location:** `src/types/index.ts:74-79`

```typescript
export interface QueryParams {
  keyCondition: {
    pk: { name: string; value: string };  // ALWAYS string
    sk?: { name: string; value: string; value2?: string };
  };
}
```

DynamoDB tables can have numeric hash/range keys. When a user enters `123` for a numeric key, it's sent as `"123"` (string), and DynamoDB rejects the query. No type auto-detection from `TableInfo.attributeDefinitions`.

**Fix:** Extend types to include value types, detect attribute types from table metadata, add type selector UI.

---

### 3. Batch Writes Aren't Actually Batched
**Location:** `electron/ipc/handlers.ts:454-555`

```typescript
// Executes ONE-BY-ONE, not batched
for (const req of requests) {
  if (req.PutRequest) {
    await docClient.send(new PutCommand({ ... }));  // Individual calls
  }
}
```

- Uses individual PUT/DELETE commands instead of `BatchWriteCommand`
- No handling of `UnprocessedItems` (items that failed due to throttling)
- No exponential backoff retry
- Silent data loss if rate limiting occurs

**Fix:** Use actual `BatchWriteCommand` (25 items per request), implement exponential backoff for unprocessed items.

---

### 4. Pending Changes Ignores Write Failures
**Location:** `src/components/TabContent.tsx:1518-1540`

```typescript
const result = await window.dynomite.batchWrite(...);
// Doesn't check result.success or result.errors
pendingChangesStore.clearChangesForTab(tabId);  // ALWAYS cleared, even on failure
```

User makes 5 changes, 3 fail silently, UI clears pending changes, user thinks all saved.

**Fix:** Check `result.errors`, only clear changes on full success, display detailed error messages.

---

## High Priority Issues

### 5. No Input Validation in IPC Handlers
**Location:** `electron/ipc/handlers.ts` (all handlers)

```typescript
ipcMain.handle('dynamo:describe-table', async (_event, profileName: string, tableName: string) => {
  // No validation - profileName/tableName could be anything
  const client = await getDynamoDBClient(profileName);
});
```

**Fix:** Validate `profileName` exists in loaded profiles, validate `tableName` format.

---

### 6. Type Duplication Between Processes
**Locations:** `electron/types.ts` and `src/types/index.ts`

Both files define nearly identical types (`AwsProfile`, `TableInfo`, `QueryParams`, `FilterCondition`, etc.). This violates DRY and leads to drift.

**Fix:** Create a shared types file imported by both processes.

---

### 7. No Retry Logic for AWS Calls
**Location:** Throughout `electron/ipc/handlers.ts`

No retries on throttling, no exponential backoff, no handling of transient errors. DynamoDB frequently throttles requests.

**Fix:** Add retry middleware or wrapper with exponential backoff for `ProvisionedThroughputExceededException`.

---

### 8. Table Open Has No Error Handling
**Location:** `src/components/TableList.tsx:94-124`

```typescript
const handleOpenTable = async (tableName: string) => {
  const tableInfo = await window.dynomite.describeTable(...);
  // No catch block - unhandled rejection
};
```

**Fix:** Add try/catch with error state and user notification.

---

## Medium Priority Issues

### 9. TabContent.tsx is 2,493 Lines
**Location:** `src/components/TabContent.tsx`

Single component handles query building, results table, inline editing, dialogs, exports. This makes it hard to test, navigate, or reuse logic.

**Fix:** Extract into sub-components:
- `<QueryBuilder>` - query form logic
- `<ResultsTableContainer>` - results handling
- Custom hooks: `useRowEditing()`, `useBatchOperations()`

---

### 10. Overuse of `Record<string, unknown>`
**Count:** 227 usages throughout codebase

```typescript
items: Record<string, unknown>[];  // Too loose
```

This loses type safety, IDE autocomplete, and attribute validation.

**Fix:** Create branded types:
```typescript
type DynamoAttributeValue = string | number | boolean | null | DynamoAttributeValue[] | Record<string, DynamoAttributeValue>;
type DynamoItem = Record<string, DynamoAttributeValue>;
```

---

### 11. Inconsistent Error Handling Across Stores
**Location:** Various stores in `src/stores/`

Some stores properly set error state, others just `console.error`. Inconsistent user experience.

**Fix:** Establish consistent error handling pattern across all stores with proper error state management.

---

### 12. Map Used in Zustand Store
**Location:** `src/stores/pending-changes-store.ts:21`

```typescript
changesByTab: Map<string, PendingChange[]>;
```

Maps don't serialize to JSON. If persistence is ever added to this store, it will break silently.

**Fix:** Use plain object instead of Map, or ensure this store is never persisted.

---

## Low Priority / Enhancements

### 13. Missing Accessibility Features
- No ARIA labels on interactive elements
- No keyboard navigation in tables
- Icon-only buttons without accessible labels
- Color-dependent alerts without text alternatives

**Fix:** Add `aria-label` to icon buttons, implement keyboard navigation for table rows.

---

### 14. No Test Coverage
The codebase appears to have minimal testing. Critical paths like query execution, batch operations, and IPC handlers have no tests.

**Fix:** Add tests starting with:
1. IPC handler unit tests (mock AWS SDK)
2. Store integration tests
3. Critical component tests (query builder validation)

---

### 15. Missing Features to Consider

1. **Query History** - Save and replay previous queries per table
2. **Export to Multiple Formats** - Currently only JSON/CSV, add Parquet, SQL INSERT statements
3. **Saved Filters** - Bookmark complex filter combinations
4. **Table Comparison** - Diff items between profiles (useful for staging vs prod)
5. **Query Templates** - Preset queries for common access patterns based on GSIs
6. **Keyboard Shortcuts** - Ctrl+Enter to run query, Ctrl+S to save changes
7. **Auto-refresh** - Optional polling for real-time table views
8. **Item Validation** - Validate items against table schema before writes

---

## Summary

| Priority | Count | Impact |
|----------|-------|--------|
| Critical | 4 | Data corruption, silent failures |
| High | 4 | Security, reliability, maintainability |
| Medium | 4 | Code quality, type safety |
| Low | 3 | UX, testing, features |

**Top 3 actions to take immediately:**
1. Fix query progress race condition (Bug #1) - this causes visible data corruption
2. Fix batch write implementation (Bug #3) - causes silent data loss
3. Fix pending changes error handling (Bug #4) - causes users to think writes succeeded

The architecture is sound - proper process separation, modern tooling, good state management patterns. The issues are mostly implementation bugs and missing error handling rather than fundamental design problems.
